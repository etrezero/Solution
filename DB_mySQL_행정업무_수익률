import pymysql
import pandas as pd
import dash
from dash import dcc, html, Input, Output, State, dash_table
from datetime import datetime
from dateutil.relativedelta import relativedelta
import json
import os
from openpyxl import Workbook
import plotly.graph_objs as go
import re
import numpy as np



# JSON 파일 경로
Path_DB_json = r'C:\Covenant\data\0.DB_Table.json'


# JSON 파일을 읽어 DataFrame으로 변환
with open(Path_DB_json, 'r', encoding='utf-8') as f:
    data = json.load(f)
    df_db = pd.DataFrame(data)

df_db = df_db[['테이블한글명', '테이블영문명', '칼럼명(한글)', '칼럼명(영문)']]



# 드롭다운 목록 생성
table_options = [{'label': row['테이블한글명'], 'value': row['테이블영문명']} for index, row in df_db.iterrows()]
table_options = list({v['value']: v for v in table_options}.values())







솔루션운용역 = {
    'T08186' : '서재영',
    'T10054' : '민상구',
    'T10559' : '정지영',
    'T08687' : '박은설',
}







app = dash.Dash(__name__)
app.title = 'DB_mySQL_행정업무_수익률'
server = app.server



app.layout = html.Div(
    style={'width': '70%', 'margin': 'auto'},
    children=[

        dcc.Dropdown(
            id='table-dropdown',
            options=table_options,
            value=next(
                (option['value'] for option in table_options 
                if option['label'] == '펀드기준가'), 
                None),
            style={'width': '50%', 'margin': '10px'}
        ),
        dcc.Dropdown(
            id='column-dropdown',
            multi=True,
            value=[
            'STD_DT', 'FUND_CD', 'OPNG_AMT', 'NAST_AMT', 
            'MOD_STPR', 'MNR_EMNO'
            ],
            
            placeholder='Table 컬럼 선택(중복가능)',
            style={'width': '50%', 'margin': '10px'}
        ),
        dcc.DatePickerRange(
            id='date-picker-range',
            start_date=(datetime.today() - relativedelta(years=1)).replace(month=12, day=29).strftime('%Y-%m-%d'),
            end_date=datetime.today().strftime('%Y-%m-%d'),
            display_format='YYYYMMDD',
            style={'width': '50%', 'margin-left': '19px'}
        ),
        dcc.Dropdown(
            id='string-filter-column-dropdown',
            placeholder='문자열 조건 적용할 컬럼',
            style={'width': '50%', 'margin': '10px'}
        ),
        dcc.Input(
            id='filter-input',
            type='text',
            placeholder='포함할 문자열(콤마로구분)',
            style={'width': '30%', 'margin': '10px auto'}
        ),
        dcc.Input(
            id='exclude-input',
            type='text',
            placeholder='제외할 문자열',
            # value='',
            style={'width': '30%', 'margin': '10px auto'}
        ),
        html.Button('쿼리 실행', id='execute-query', n_clicks=0, style={'width': '30%', 'margin': '10px auto'}),

        # 기존 db-table 유지
        dash_table.DataTable(
            id='db-table',
            columns=[{"name": col, "id": col} for col in df_db.columns],
            data=df_db.to_dict('records'),
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'left', 'padding': '5px', 'minWidth': '100px', 'maxWidth': '200px', 'whiteSpace': 'normal'},
            style_header={'backgroundColor': 'white', 'fontWeight': 'bold'},
            style_as_list_view=True,
            page_size=15  # 페이지 사이즈 설정
        ),

        html.Div(style={'height': '40px'}),

        



        dash_table.DataTable(
            id='query-result-table',
            style_table={'overflowX': 'auto'},
            style_cell={'textAlign': 'left', 'padding': '5px', 'minWidth': '100px', 'maxWidth': '200px', 'whiteSpace': 'normal'},
            style_header={'backgroundColor': 'white', 'fontWeight': 'bold'},
            style_as_list_view=True,
            page_size=15  # 페이지 사이즈 설정
        ),

        html.Button('엑셀로 다운로드', id='download-excel', n_clicks=0, style={'width': '30%', 'margin': '10px auto'}),
        dcc.Download(id="download"),



        # Return으로 받은 Store 컴포넌트
        dcc.Store(id='df-store-query'),
        dcc.Store(id='df-store-pivot'),



        # df-store에 저장된 피벗 테이블 결과를 보여줄 영역 추가
        html.Div(id='pivot-table-output'),  


    ]
)

# 컬럼과 테이블 데이터를 업데이트하는 콜백 함수 (db-table 유지)
@app.callback(
    [Output('column-dropdown', 'options'),
     Output('db-table', 'data')],
    [Input('table-dropdown', 'value')]
)
def update_columns_and_table(selected_table):
    if selected_table is None:
        return (None, None)

    filtered_df = df_db[df_db['테이블영문명'] == selected_table]
    column_options = [{'label': row['칼럼명(한글)'], 'value': row['칼럼명(영문)']} for index, row in filtered_df.iterrows()]

    return column_options, filtered_df.to_dict('records')


@app.callback(
    [Output('df-store-query', 'data'),
     Output('df-store-pivot', 'data')],

    Input('execute-query', 'n_clicks'),
    [State('table-dropdown', 'value'),
     State('column-dropdown', 'value'),
     State('date-picker-range', 'start_date'),
     State('date-picker-range', 'end_date'),
     State('string-filter-column-dropdown', 'value'),
     State('filter-input', 'value'),
     State('exclude-input', 'value')]
)
def update_table(n_clicks, selected_table, selected_columns, start_date, end_date, filter_column, include_str, exclude_str):
    if n_clicks == 0 or not selected_table or not selected_columns:
        return (None, None) #리턴이 2개라, 튜플형태는 ()

    connection = pymysql.connect(
        host='192.168..',
        user='solution',
        password='',
        database='dt',
        port=3306,
        cursorclass=pymysql.cursors.DictCursor
    )

    def execute_query(query):
        try:
            with connection.cursor() as cursor:
                cursor.execute(query)
                result = cursor.fetchall()
                return pd.DataFrame(result)
        except Exception as e:
            print(f"Error executing query: {e}")
            return None

    try:
        # 쿼리 생성 (최신 데이터와 start_date로 주어진 데이터를 모두 가져오는 쿼리)
        query = f"""
            SELECT {selected_table}.FUND_CD, {', '.join([f"{selected_table}.{col}" for col in selected_columns if col != 'FUND_CD'])},
                DWPI10011.FUND_NM
            FROM {selected_table} 
            JOIN DWPI10011 ON {selected_table}.FUND_CD = DWPI10011.FUND_CD
            WHERE 
                (
                    {selected_table}.{selected_columns[0]} = (SELECT MAX({selected_columns[0]}) FROM {selected_table})
                    OR {selected_table}.{selected_columns[0]} = '{start_date.replace('-', '')}'
                    OR {selected_table}.{selected_columns[0]} = DATE_FORMAT(DATE_SUB((SELECT MAX(STR_TO_DATE({selected_columns[0]}, '%Y%m%d')) FROM {selected_table}), INTERVAL 7 DAY), '%Y%m%d')
                    OR {selected_table}.{selected_columns[0]} = DATE_FORMAT(DATE_SUB((SELECT MAX(STR_TO_DATE({selected_columns[0]}, '%Y%m%d')) FROM {selected_table}), INTERVAL 1 MONTH), '%Y%m%d')
                    OR {selected_table}.{selected_columns[0]} = DATE_FORMAT(DATE_SUB((SELECT MAX(STR_TO_DATE({selected_columns[0]}, '%Y%m%d')) FROM {selected_table}), INTERVAL 3 MONTH), '%Y%m%d')
                    OR {selected_table}.{selected_columns[0]} = DATE_FORMAT(DATE_SUB((SELECT MAX(STR_TO_DATE({selected_columns[0]}, '%Y%m%d')) FROM {selected_table}), INTERVAL 6 MONTH), '%Y%m%d')
                    OR {selected_table}.{selected_columns[0]} = DATE_FORMAT(DATE_SUB((SELECT MAX(STR_TO_DATE({selected_columns[0]}, '%Y%m%d')) FROM {selected_table}), INTERVAL 1 YEAR), '%Y%m%d')
                )
        """

        if include_str:
            include_conditions = [f"{filter_column} LIKE '%{inc}%'" for inc in include_str.split(',')]
            query += " AND " + " OR ".join(include_conditions)

        if exclude_str:
            exclude_conditions = [f"{filter_column} NOT LIKE '%{exc}%'" for exc in exclude_str.split(',')]
            query += " AND " + " OR ".join(exclude_conditions)


        df_select = execute_query(query)
        df_select = pd.DataFrame(df_select)


        df_select = df_select[
        ((df_select['FUND_NM'].str.contains(r'(모)|모투자신탁')) |
        df_select['FUND_NM'].str.contains(r'퇴직연금자산배분일반사모|SSelection|Dream|S자산배분|DB|처브|ABL')) &
        (~df_select['FUND_NM'].str.contains(r'\(A\)|\(C\)'))
]

        


        # 솔루션운용역.keys()를 정규식 패턴으로 변환
        pattern = "|".join(map(re.escape, 솔루션운용역.keys()))  # 각 키를 정규식 패턴으로 변환
        # MNR_EMNO 열에서 pattern을 포함하는 행만 선택
        df_select = df_select[df_select['MNR_EMNO'].str.contains(pattern, na=False)]
        print(df_select)
        
        # save_excel(df_select, 'df_select', index_option=False)

        connection.close()

        if df_select is not None:
             return df_select.to_dict('records'), df_select.to_dict('records')  # 두 저장소에 저장
    
        else:
            return (None, None)

    except Exception as e:
        print(f"Error executing query: {e}")
        connection.close()
        return (None, None)





# 데이터를 테이블에 표시
@app.callback(
    [Output('query-result-table', 'columns'),
     Output('query-result-table', 'data')],
    Input('df-store-query', 'data')
)
def update_table_display(data):
    if data is None:
        return [], []

    df = pd.DataFrame(data)
    columns = [{"name": col, "id": col} for col in df.columns]
    return columns, df.to_dict('records')




# 피벗 테이블 생성 및 출력
@app.callback(
    Output('pivot-table-output', 'children'),
    Input('df-store-pivot', 'data')
)
def generate_pivot_table(data):
    if data is None:
        return "pivot table 데이터 없음"

    df = pd.DataFrame(data)
    
    
    

    #빈티지 열을 추가하여 빈티지 표시
    df.loc[df['FUND_NM'].str.contains('TIF'), '빈티지'] = 'TIF'
    df.loc[df['FUND_NM'].str.contains('2030'), '빈티지'] = '2030'
    df.loc[df['FUND_NM'].str.contains('2035'), '빈티지'] = '2035'
    df.loc[df['FUND_NM'].str.contains('2040'), '빈티지'] = '2040'
    df.loc[df['FUND_NM'].str.contains('2045'), '빈티지'] = '2045'
    df.loc[df['FUND_NM'].str.contains('2050'), '빈티지'] = '2050'
    df.loc[df['FUND_NM'].str.contains('2055'), '빈티지'] = '2055'
    df.loc[df['FUND_NM'].str.contains('2060'), '빈티지'] = '2060'
    df.loc[~df['FUND_NM'].str.contains('2030|2035|2040|2045|2050|2055|2060|TIF'), '빈티지'] = '기타'


    #특수 (포커스 - TRP)
    df.loc[df['FUND_NM'].str.contains('포커스'), '특수'] = '포커스'
    df.loc[df['FUND_NM'].str.contains('한국투자') & ~df['FUND_NM'].str.contains('포커스'), '특수'] = 'TRP'


    #디폴트 열을 추가하여 O표시
    df.loc[df['FUND_NM'].str.contains('O'), '디폴트'] = 'O'

    

    

    










    # 판매사별 ===================================================
    PV = df.pivot_table(
        index='STD_DT', 
        columns=['FUND_CD','FUND_NM',],
        values='MOD_STPR',
        aggfunc='mean',
        fill_value=0,
        margins=False
    )
    
    print("PV=====================", PV)
    # save_excel(PV, 'PV', index_option=True)
    

    # MultiIndex의 레벨([0],[1],[2])에서 리스트 또는 딕셔너리의 키에 해당하는 열만 선택
    fiter_column = [
                        # col for col in PV.columns 
                        # if col[0] in 솔루션운용역.keys()
                        # and '(모)' not in col[2] 
                        # and '모투자신탁' not in col[2]
        ]

    # 인덱스 열(STD_DT)을 포함하여 테이블로 변환
    # PV = PV[fiter_column]
    
    
   # [멀티인덱스문제] STD_DT가 인덱스에 있는 경우 인덱스를 열로 변환
    if 'STD_DT' in PV.index.names:
        PV = PV.reset_index(level='STD_DT')

    # 이제 'STD_DT'를 datetime으로 변환하고, 인덱스로 재설정합니다
    PV['STD_DT'] = pd.to_datetime(PV['STD_DT'], errors='coerce')
    PV.set_index('STD_DT', inplace=True)

    # 인덱스에 날짜 형식 적용
    PV.index = PV.index.strftime('%Y-%m-%d')
    
    
    PV.columns = PV.columns.droplevel([0])
    print('PV================', PV)



    수익률 = PV.iloc[-1]/PV-1
    수익률.replace([np.inf, -np.inf, np.nan], '', inplace=True)
    수익률 = 수익률.sort_index(ascending=False)   #내림차순정렬


    print('수익률===============', 수익률)

    # 수익률 행 이름 재지정
    수익률.index = ['Today', '1W', '1M', '3M', '6M', 'YTD', '1Y']

    수익률 = 수익률.drop('Today')
    
    


    # # 'FUND_NM'만 남기고 나머지 레벨을 제거
    # 수익률.columns = 수익률.columns.droplevel([0,1])
    

    # print('수익률========================', 수익률)
    # print('수익률.T========================', 수익률.T)
    
    



    # 인덱스를 열로 설정. 테이블에 열 데이터 딕트레코드에 포함되서 날짜나옴
    df_수익률 = 수익률.T.reset_index().rename(columns={'index': 'FUND_NM'})
    
    # 'FUND_NM' 열을 문자열 형식으로 고정
    df_수익률['FUND_NM'] = df_수익률['FUND_NM'].astype(str)
    
    # 수치형 데이터에만 백분율 형식 적용
    df_수익률 = df_수익률.applymap(lambda x: f"{x:.2%}" if pd.notnull(x) and isinstance(x, (int, float)) else x)

    df_수익률 = df_수익률.sort_values(by='YTD', ascending=True)  #오름차순 정렬
    df_수익률 = df_수익률[~((df_수익률['1W'] == "") | (df_수익률['1W'].isna()) | (df_수익률['1W'] == 0))]
        

    print('df_수익률========================', df_수익률)
    save_excel(df_수익률, 'df_수익률', index_option=True)
    


    # #===========================================
    # TDF = [
    #                 col for col in PV.columns 
    #                 if 'TDF' in col[2] 
    # ]

    
    # TIF = [
    #                 col for col in PV.columns 
    #                 if 'TIF' in col[2] 
    # ]


    # TRP = [
    #                 col for col in PV.columns 
    #                 if '알아서' in col[2] 
    #                 and '포커스' not in col[2]
    #                 and '골드2080' not in col[2]
    # ]

   
    # TRP_TDF = [
    #                 col for col in TRP
    #                 if 'TDF' in TRP
                    
    # ]


    # TRP_TIF = [
    #                 col for col in TRP
    #                 if 'TIF' in TRP
                    
    # ]



    # 포커스 = [
    #                 col for col in PV.columns 
    #                 if '포커스' in col[2] 
    #                 or '골드2080' in col[2] 
    # ]




    # 포커스_TDF = [
    #                 col for col in 포커스
    #                 if 'TDF' in 포커스
    # ]


    # 포커스_TIF = [
    #                 col for col in 포커스
    #                 if 'TIF' in 포커스
    # ]


    

    # 솔루션 = [
    #                 col for col in PV.columns 
    #                 if '솔루션' in col[2] 
    #                 or 'SSelection' in col[2] 
    #                 or '소부장' in col[2] 
    # ]



    # S자산배분 = [
    #                 col for col in PV.columns 
    #                 if 'S자산배분' in col[2]  
    # ]


    # DB생명 = [
    #                 col for col in PV.columns 
    #                 if 'Dream' in col[2]  
    #                 or 'DB' in col[2] 
    # ]

    
    # 기타자산배분 = [
    #                 col for col in PV.columns 
    #                 if 'EMP' in col[2]  
    #                 or '퇴직연금자산배분' in col[2] 
    #                 or '다이나믹헤지' in col[2] 
    # ]
    
    # #======================================================

    





    return html.Div([
        


    # 수익률==================================
        html.H4("수익률(억원)      솔루션(ELS/코스피솔루션/S셀렉션)"),
    
        dash_table.DataTable(
        columns=[{"name": col, "id": col} for col in df_수익률.columns],  # 인덱스 열 포함
        data=df_수익률.to_dict('records'),  # 데이터 변환
        style_table={'overflowX': 'auto'},
        style_cell={
            'textAlign': 'center', 
            'padding': '5px', 
            'minWidth': '100px', 
            'maxWidth': '200px', 
            'whiteSpace': 'normal'
        },
        style_header={
            'backgroundColor': 'white', 
            'fontWeight': 'bold', 
            'textAlign': 'center'
        },
        style_header_conditional=[
            {
                'if': {'column_id': col},
                'backgroundColor': '#3762AF',
                'color': 'white'
            } for col in df_수익률.columns if 'YTD' in col
        ],
        style_cell_conditional=[
            {
                'if': {'column_id': df_수익률.columns[0]},  # 첫 번째 열에 대해 적용
                'textAlign': 'left'
            }
        ],
        sort_action="native",      # 열 소팅 기능 활성화
        filter_action="native",    # 필터 기능 활성화
        style_as_list_view=True,
        page_size=15  # 페이지 사이즈 설정
    ),









    ])





@app.callback(
    Output("download", "data"),
    Input("download-excel", "n_clicks"),
    State('query-result-table', 'data'),  
    prevent_initial_call=True,
)
def download_as_excel(n_clicks, table_data):
    if not table_data:
        return None
    df = pd.DataFrame(table_data)
    return dcc.send_data_frame(df.to_excel, "query_result.xlsx", sheet_name="Sheet1")






#엑셀 저장=======================================================
def save_excel(df, sheetname, index_option=None):
    
    # 파일 경로
    path = rf'C:\Covenant\data\DB_mySQL_행정업무_수익률.xlsx'

    # 파일이 없는 경우 새 Workbook 생성
    if not os.path.exists(path):
        wb = Workbook()
        wb.save(path)
        print(f"새 파일 '{path}' 생성됨.")
    
    # 인덱스를 날짜로 변환 시도
    try:
        # index_option이 None일 경우 인덱스를 포함하고 날짜 형식으로 저장
        if index_option is None or index_option:  # 인덱스를 포함하는 경우
            df.index = pd.to_datetime(df.index, errors='raise')  # 변환 실패 시 오류 발생
            df.index = df.index.strftime('%Y-%m-%d')  # 벡터화된 방식으로 날짜 포맷 변경
            index = True  # 인덱스를 포함해서 저장
        else:
            index = False  # 인덱스를 제외하고 저장
    except Exception:
        print("Index를 날짜 형식으로 변환할 수 없습니다. 기본 인덱스를 사용합니다.")
        index = index_option if index_option is not None else True  # 변환 실패 시에도 인덱스를 포함하도록 설정

    # DataFrame을 엑셀 시트로 저장
    with pd.ExcelWriter(path, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
        df.to_excel(writer, sheet_name=sheetname, index=index)  # index 여부 설정
        print(f"'{sheetname}' 저장 완료.")








# 앱 실행
if __name__ == '__main__':
    app.run_server(debug=False, host='0.0.0.0', port=8050)
